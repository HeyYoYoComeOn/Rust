fn main() {
    let a = 12;
    println!("Hello, world!");
    println!("The number is {}",a);
    println!("The first number is {},another number is {}",a,a);

    const b: i32= 456;
    let b  = 789; // 如果先设置b为const常量的话，再次let b的话就会报错。
    println!("The number is {}",b);

    let _c: u64 = 128; //这里声明了 c 为无符号 64 位整型变量，如果没有声明类型，a 将自动被判断为有符号 32 位整型变量，这对于 a 的取值范围有很大的影响。

    let d = 250;
    d = 320; //这段代码就是错误的，因为尽管b是一个变量，但是b是不可变的变量，也就是说b是固定等于 250 的。
    
    let mut _e = 360;
    _e = 370; // 但是如果写成以上代码的样子就可以了，"可变"（mutable）只需一个 mut 关键字。

    //重影（Shadowing）
    //重影就是刚才讲述的所谓"重新绑定"，之所以加引号就是为了在没有介绍这个概念的时候代替一下概念。
    //重影就是指变量的名称可以被重新使用的机制： 看以下代码
    let f = 6;
    let f = f + 1;
    let f = f * 2;
    let f = "Hello, world";
    println!("The value of the f is : {}", f); //f也是一个不可变的变量但是如果我们这么写是因为f这个名字被重新代表了一个变量实体.
    //重影与可变变量的赋值不是一个概念，重影是指用同一个名字重新代表另一个变量实体，其类型、可变属性和值都可以变化。但可变变量赋值仅能发生值的变化。
}

fn next(){
    //Rust 语言中的基础数据类型有以下几种。
    //整数型（Integer）
    //整数型简称整型，按照比特位长度和有无符号分为一下种类：
    //位长度	                    有符号	                         无符号
    //8-bit	                         i8	                             u8
    //16-bit	                     i16	                         u16
    //32-bit	                     i32	                         u32
    //64-bit	                     i64	                         u64
    //128-bit	                     i128	                         u128
    //arch	                         isize	                         usize
    //isize 和 usize 两种整数类型是用来衡量数据大小的，它们的位长度取决于所运行的目标平台，如果是 32 位架构的处理器将使用 32 位位长度整型。

    //整数的表述方法有以下几种：

    //进制	                    例
    //十进制 	                98_222
    //十六进制	                0xff
    //八进制	                0o77
    //二进制	                0b1111_0000
    //字节(只能表示 u8 型)	b'A'

    let x = 2.0;  //f32浮点数和f64浮点数rust都支持且计算机处理速度大致相同，但是64位浮点的精度更高一些
    let y: f32 = 3.0;

    //以下是数学运算
    fn main() {
        let sum = 5 + 10; // 加
        let difference = 95.5 - 4.3; // 减
        let product = 4 * 30; // 乘
        let quotient = 56.7 / 32.2; // 除
        let remainder = 43 % 5; // 求余
    }

    //许多运算符号之后加上 = 号是自运算的意思，例如：
    //sum += 1 等同于 sum = sum + 1。
    //注意：Rust 不支持 ++ 和 --，因为这两个运算符出现在变量的前后会影响代码可读性，减弱了开发者对变量改变的意识能力。

    //布尔型
    //布尔型用 bool 表示，值只能为 ‘true’ 或 ‘false’。
    
    //字符型
    //字符型用 char 表示。

    //Rust的 char 类型大小为 4 个字节，代表 Unicode标量值，这意味着它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格在 Rust 中都是有效的 char 值。
    //Unicode 值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （包括两端）。 但是，"字符"这个概念并不存在于 Unicode 中，因此您对"字符"是什么的直觉可能与Rust中的字符概念不匹配。所以一般推荐使用字符串储存 UTF-8 文字（非英文字符尽可能地出现在字符串中）。

    //注意：由于中文文字编码有两种（GBK 和 UTF-8），所以编程中使用中文字符串有可能导致乱码的出现，这是因为源程序与命令行的文字编码不一致，所以在 Rust 中字符串和字符都必须使用 UTF-8 编码，否则编译器会报错。

    //复合类型
    //元组是用一对 ( ) 包括的一组数据，可以包含不同种类的数据：
    let sub: (i32,f64,u8) = (500, 6.4, 1);
    //sub.0 = 500;
    //sub.1 = 6.4;
    //sub.2 = 1;
    let (j,k,l) = sub;
    // k = 6.4;

    //数组的定义是用一对 [ ] 包括的同类型数据。

    let z = [1,2,3,4,5];
    // z 是一个长度为 5 的整型数组
    let x = ["January", "February", "March"];
    // x 是一个长度为 3 的字符串数组
    let v: [i32; 5] = [1, 2, 3, 4, 5];
    // v 是一个长度为 5 的 i32 数组
    let i = [3; 5];
    // 等同于 let i = [3, 3, 3, 3, 3];
    let first = i[0];
    let second = i [2];
    // 数组访问
    v[0] = 123; // 错误：数组 v 不可变
    let mut s = [1, 2, 3];
    s[0] = 4; // 正确
}